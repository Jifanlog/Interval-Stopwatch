<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Countdown Phases</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      background-color: #f4f4f4;
      padding: 20px;
    }
    .phase {
      border: 1px solid #ccc;
      background: #fff;
      padding: 10px;
      margin: 10px;
      width: 300px;
    }
    .phase h2 {
      margin-top: 0;
    }
    .timer,
    .phase h2 {
      font-size: 1.5em;
    }
    .fade-out {
      opacity: 0;
      transition: opacity 1s ease-out;
    }
    button, input {
      font-size: 1em;
      padding: 5px;
      margin: 5px;
      cursor: pointer;
    }
    #runningDisplay {
      margin-top: 20px;
      text-align: center;
    }
  </style>
</head>
<body>
  <label>
    Prevent Screen Sleep:
    <input type="checkbox" id="wakeLockToggle" />
  </label>
  <div>
    <button id="addPhase">Add Phase</button>
  </div>
  <!-- Container for building phases -->
  <div id="phasesContainer"></div>
  
  <div>
    <button id="start">Start</button>
    <button id="stop">Stop</button>
    <button id="reset">Reset</button>
  </div>
  
  <!-- Running display (hidden during setup) -->
  <div id="runningDisplay" style="display:none;"></div>
  
  <script>
    let phases = []; // Each phase: { repeat: number, timers: [{ minutes, seconds }] }
    let running = false;
    let wakeLock = null;
    let wakeLockEnabled = false;
    let currentTimerInterval = null; // holds the current timer interval (for stop functionality)
    
    async function requestWakeLock() {
      if ('wakeLock' in navigator && wakeLockEnabled) {
        try {
          wakeLock = await navigator.wakeLock.request('screen');
          console.log('Wake Lock is active');
        } catch (err) {
          console.error('Wake Lock request failed:', err);
        }
      }
    }
    
    function releaseWakeLock() {
      if (wakeLock !== null) {
        wakeLock.release().then(() => {
          wakeLock = null;
          console.log('Wake Lock released');
        });
      }
    }
    
    document.getElementById("wakeLockToggle").addEventListener("change", function() {
      wakeLockEnabled = this.checked;
      if (!wakeLockEnabled) {
        releaseWakeLock();
      }
    });
    
    // ------------------------
    // Phase & Timer Setup Code
    // ------------------------
    function addPhase() {
      const phaseIndex = phases.length;
      const phase = {
        repeat: 1, // default repeat count
        timers: [] // each timer is { minutes, seconds }
      };
      phases.push(phase);
      
      // Create a UI element for this phase
      const phaseDiv = document.createElement("div");
      phaseDiv.className = "phase";
      phaseDiv.id = `phase${phaseIndex}`;
      
      const header = document.createElement("h2");
      header.textContent = `Phase ${phaseIndex + 1}`;
      phaseDiv.appendChild(header);
      
      // Input for repeat count
      const repeatLabel = document.createElement("label");
      repeatLabel.textContent = "Repeat:";
      phaseDiv.appendChild(repeatLabel);
      
      const repeatInput = document.createElement("input");
      repeatInput.type = "number";
      repeatInput.min = "1";
      repeatInput.value = "1";
      repeatInput.style.width = "50px";
      repeatInput.addEventListener("change", function() {
        phase.repeat = parseInt(this.value);
      });
      phaseDiv.appendChild(repeatInput);
      
      // Container for timers of this phase
      const timerContainer = document.createElement("div");
      timerContainer.className = "timerContainer";
      timerContainer.id = `phase${phaseIndex}Timers`;
      phaseDiv.appendChild(timerContainer);
      
      // Inputs for adding a timer to this phase
      const minLabel = document.createElement("label");
      minLabel.textContent = "Minutes:";
      phaseDiv.appendChild(minLabel);
      
      const minInput = document.createElement("input");
      minInput.type = "number";
      minInput.min = "0";
      minInput.style.width = "50px";
      phaseDiv.appendChild(minInput);
      
      const secLabel = document.createElement("label");
      secLabel.textContent = "Seconds:";
      phaseDiv.appendChild(secLabel);
      
      const secInput = document.createElement("input");
      secInput.type = "number";
      secInput.min = "0";
      secInput.max = "59";
      secInput.style.width = "50px";
      secInput.addEventListener("input", function() {
        if (this.value > 59) { this.value = 59; }
        if (this.value < 0) { this.value = 0; }
      });
      phaseDiv.appendChild(secInput);
      
      const addTimerBtn = document.createElement("button");
      addTimerBtn.textContent = "Add Timer";
      addTimerBtn.addEventListener("click", function() {
        const minutes = parseInt(minInput.value) || 0;
        const seconds = parseInt(secInput.value) || 0;
        if (minutes === 0 && seconds === 0) return;
        phase.timers.push({ minutes, seconds });
        
        // Display the added timer inside the phase
        const timerDisplay = document.createElement("div");
        timerDisplay.className = "timer";
        timerDisplay.textContent = `${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}`;
        timerContainer.appendChild(timerDisplay);
        
        // Clear inputs
        minInput.value = "";
        secInput.value = "";
      });
      phaseDiv.appendChild(addTimerBtn);
      
      document.getElementById("phasesContainer").appendChild(phaseDiv);
    }
    
    document.getElementById("addPhase").addEventListener("click", addPhase);
    
    // ------------------------
    // Running the Phases
    // ------------------------
    // Runs a single timer (counts down from timer.minutes:timer.seconds)
    // and updates the provided display element.
    function runTimer(timer, displayElement) {
      return new Promise((resolve) => {
        let minutes = timer.minutes;
        let seconds = timer.seconds;
        displayElement.textContent = `${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}`;
        currentTimerInterval = setInterval(() => {
          if (seconds === 0) {
            if (minutes === 0) {
              clearInterval(currentTimerInterval);
              displayElement.classList.add("fade-out");
              setTimeout(() => {
                resolve();
              }, 1000);
            } else {
              minutes--;
              seconds = 59;
            }
          } else {
            seconds--;
          }
          displayElement.textContent = `${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}`;
        }, 1000);
      });
    }
    
    // Runs all phases sequentially.
    // For each phase, it repeats the timer sequence as specified.
    async function startPhases() {
      running = true;
      if (wakeLockEnabled) await requestWakeLock();
      
      // Hide setup UI and show the running display.
      document.getElementById("phasesContainer").style.display = "none";
      const runningDisplay = document.getElementById("runningDisplay");
      runningDisplay.style.display = "block";
      
      for (let phaseIndex = 0; phaseIndex < phases.length; phaseIndex++) {
        const phase = phases[phaseIndex];
        for (let rep = 0; rep < phase.repeat; rep++) {
          // Show phase and repetition info.
          runningDisplay.innerHTML = `<h2>Phase ${phaseIndex + 1} - Repeat ${rep + 1} of ${phase.repeat}</h2>`;
          // Run each timer in the phase sequentially.
          for (let timerIndex = 0; timerIndex < phase.timers.length; timerIndex++) {
            const timer = phase.timers[timerIndex];
            const timerDiv = document.createElement("div");
            timerDiv.className = "timer";
            runningDisplay.appendChild(timerDiv);
            await runTimer({ ...timer }, timerDiv);
          }
        }
      }
      runningDisplay.innerHTML = "<h2>All phases completed!</h2>";
      releaseWakeLock();
      running = false;
    }
    
    document.getElementById("start").addEventListener("click", startPhases);
    
    // ------------------------
    // Stop & Reset Functions
    // ------------------------
    function stopTimers() {
      running = false;
      if (currentTimerInterval) {
        clearInterval(currentTimerInterval);
      }
      releaseWakeLock();
    }
    
    document.getElementById("stop").addEventListener("click", stopTimers);
    
    function resetAll() {
      stopTimers();
      phases = [];
      document.getElementById("phasesContainer").innerHTML = "";
      document.getElementById("phasesContainer").style.display = "block";
      document.getElementById("runningDisplay").style.display = "none";
    }
    
    document.getElementById("reset").addEventListener("click", resetAll);
  </script>
</body>
</html>
